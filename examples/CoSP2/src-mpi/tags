!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABS	constants.h	9;"	d
BIN_DIR	Makefile	/^BIN_DIR=..\/bin$/;"	m
CC	Makefile	/^CC = mpic++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=gnu++0x -fopenmp -D$(DIAGPOS)$/;"	m
CMDLINEPARSER_H_	cmdLineParser.h	8;"	d
CONTIG_MATRIX	Makefile	/^CONTIG_MATRIX = ON$/;"	m
C_LIB	Makefile	/^C_LIB = -lm$/;"	m
CoSP2_EXE	Makefile	/^CoSP2_EXE = ${BIN_DIR}\/${CoSP2_VARIANT}$/;"	m
CoSP2_VARIANT	Makefile	/^CoSP2_VARIANT = CoSP2-parallel$/;"	m
CoSP2_VARIANT	Makefile	/^CoSP2_VARIANT = CoSP2-serial$/;"	m
Command	mycommand.h	/^} Command;$/;"	t	typeref:struct:CommandSt
CommandSt	mycommand.h	/^typedef struct CommandSt$/;"	s
Counter	performance.c	/^} Counter;$/;"	t	typeref:struct:CounterSt	file:
CounterHandle	performance.h	/^enum CounterHandle {$/;"	g
CounterSt	performance.c	/^typedef struct CounterSt$/;"	s	file:
DIAGPOS	Makefile	/^DIAGPOS = POS1$/;"	m
DOUBLE_PRECISION	Makefile	/^DOUBLE_PRECISION = ON$/;"	m
DO_MPI	Makefile	/^DO_MPI = ON$/;"	m
Domain	decomposition.h	/^} Domain;$/;"	t	typeref:struct:DomainSt
DomainSt	decomposition.h	/^typedef struct DomainSt$/;"	s
EMT1	mytype.h	11;"	d
EMT1	mytype.h	15;"	d
FMT1	mytype.h	10;"	d
FMT1	mytype.h	14;"	d
HALF	constants.h	/^static const real_t HALF = 0.5;$/;"	v
HUNDRED	constants.h	/^static const int HUNDRED = 100;$/;"	v
HaloExchange	haloExchange.h	/^HaloExchange;$/;"	t	typeref:struct:HaloExchangeSt
HaloExchangeSt	haloExchange.h	/^typedef struct HaloExchangeSt$/;"	s
INCLUDES	Makefile	/^INCLUDES =$/;"	m
M	constants.h	/^int M;$/;"	v
M	mycommand.h	/^   int M;               \/\/!< max number of non-zeroes in H matrix row$/;"	m	struct:CommandSt
MAIN_FILE	CoSP2.c	43;"	d	file:
MAX	constants.h	11;"	d
MIN	constants.h	12;"	d
MPI_INCLUDE	Makefile	/^MPI_INCLUDE =$/;"	m
MPI_LIB	Makefile	/^MPI_LIB =$/;"	m
MYCOMMAND_H	mycommand.h	5;"	d
MyOption	cmdLineParser.c	/^} MyOption;$/;"	t	typeref:struct:MyOptionSt	file:
MyOptionSt	cmdLineParser.c	/^typedef struct MyOptionSt$/;"	s	file:
N	mycommand.h	/^   int N;               \/\/!< number of rows in H matrix (N x N)$/;"	m	struct:CommandSt
NonZeroMsg	haloExchange.c	/^NonZeroMsg;$/;"	t	typeref:struct:NonZeroMsgSt	file:
NonZeroMsgSt	haloExchange.c	/^typedef struct NonZeroMsgSt$/;"	s	file:
OBJECTS	Makefile	/^OBJECTS=$(SOURCES:.c=.o)$/;"	m
OPTFLAGS	Makefile	/^OPTFLAGS = -O5$/;"	m
OTHER_INCLUDE	Makefile	/^OTHER_INCLUDE =$/;"	m
OTHER_LIB	Makefile	/^OTHER_LIB =$/;"	m
REAL_MPI_TYPE	parallel.c	30;"	d	file:
REAL_MPI_TYPE	parallel.c	32;"	d	file:
RankReduceData	parallel.h	/^} RankReduceData;$/;"	t	typeref:struct:RankReduceDataSt
RankReduceDataSt	parallel.h	/^typedef struct RankReduceDataSt$/;"	s
SHELL	Makefile	/^SHELL = \/bin\/bash$/;"	m
SOURCES	Makefile	/^SOURCES=$(wildcard *.c)$/;"	m
SparseMatrix	sparseMatrix.h	/^} SparseMatrix;$/;"	t	typeref:struct:SparseMatrixSt
SparseMatrixSt	sparseMatrix.h	/^typedef struct SparseMatrixSt$/;"	s
THREE	constants.h	/^static const real_t THREE = 3.0;$/;"	v
TWO	constants.h	/^static const real_t TWO = 2.0;$/;"	v
TimerGlobal	performance.c	/^} TimerGlobal;$/;"	t	typeref:struct:TimerGlobalSt	file:
TimerGlobalSt	performance.c	/^typedef struct TimerGlobalSt$/;"	s	file:
TimerHandle	performance.h	/^enum TimerHandle{$/;"	g
Timers	performance.c	/^} Timers;$/;"	t	typeref:struct:TimersSt	file:
TimersSt	performance.c	/^typedef struct TimersSt$/;"	s	file:
ZERO	constants.h	/^static const real_t ZERO = 0.0;$/;"	v
_CONSTANTS_H_	constants.h	5;"	d
_DECOMPOSITION_H_	decomposition.h	5;"	d
_PARALLEL_H_	parallel.h	5;"	d
__GENERATE_H	generate.h	5;"	d
__HALO_EXCHANGE_	haloExchange.h	5;"	d
__MATRIXIO_H	matrixio.h	5;"	d
__MYTYPE_H_	mytype.h	5;"	d
__PERFORMANCE_H_	performance.h	4;"	d
__RANDOM_H	random.h	6;"	d
__SP2LOOP_H	sp2Loop.h	5;"	d
__SPARSEMATH_H	sparseMath.h	5;"	d
__SPARSEMATRIX_H	sparseMatrix.h	5;"	d
addArg	cmdLineParser.c	/^int addArg(const char* longOption, const char shortOption,$/;"	f
addDoubleParallel	parallel.c	/^void addDoubleParallel(double* sendBuf, double* recvBuf, int count)$/;"	f
addHaloProc	haloExchange.c	/^void addHaloProc(struct HaloExchangeSt* haloExchange, int rproc)$/;"	f
addIntParallel	parallel.c	/^void addIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
addIntReduce2	parallel.c	/^void addIntReduce2(int* value0, int* value1)$/;"	f
addRealParallel	parallel.c	/^void addRealParallel(real_t* sendBuf, real_t* recvBuf, int count)$/;"	f
addRealReduce2	parallel.c	/^void addRealReduce2(real_t* value0, real_t* value1)$/;"	f
addToCounter	performance.c	/^void addToCounter(const enum CounterHandle handle, int size)$/;"	f
allGatherData	haloExchange.c	/^void allGatherData(struct HaloExchangeSt* haloExchange, struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
alpha	mycommand.h	/^   real_t alpha;        \/\/!< alpha$/;"	m	struct:CommandSt
amp	mycommand.h	/^   real_t amp;          \/\/!< amplitude$/;"	m	struct:CommandSt
argFlag	cmdLineParser.c	/^   int argFlag;$/;"	m	struct:MyOptionSt	file:
atomAllRate	performance.c	/^   double atomAllRate;    \/\/!< average time (us) per atom$/;"	m	struct:TimerGlobalSt	file:
atomRate	performance.c	/^   double atomRate;       \/\/!< average time (us) per atom per rank $/;"	m	struct:TimerGlobalSt	file:
atomsPerUSec	performance.c	/^   double atomsPerUSec;   \/\/!< average atoms per time (us)$/;"	m	struct:TimerGlobalSt	file:
average	performance.c	/^   double average;     \/\/!< average over ranks$/;"	m	struct:CounterSt	file:
average	performance.c	/^   double average;     \/\/!< average over ranks$/;"	m	struct:TimersSt	file:
bandwidth	sparseMatrix.h	/^  int bandwidth;      \/\/!< bandwidth of matrix$/;"	m	struct:SparseMatrixSt
barrierParallel	parallel.c	/^void barrierParallel()$/;"	f
bcastParallel	parallel.c	/^void bcastParallel(void* buf, int count, int root)$/;"	f
bufferSize	haloExchange.h	/^  int bufferSize;  \/\/!< max size in bytes for send\/receive buffer$/;"	m	struct:HaloExchangeSt
builtWithMpi	parallel.c	/^int builtWithMpi(void)$/;"	f
collectCounter	performance.h	91;"	d
collectCounter	performance.h	97;"	d
count	performance.c	/^   uint64_t count;     \/\/!< current call count$/;"	m	struct:TimersSt	file:
count	performance.c	/^   uint64_t count;     \/\/!< number of values$/;"	m	struct:CounterSt	file:
counterName	performance.c	/^char* counterName[numberOfCounters] = {$/;"	v
debug	constants.h	/^int debug;$/;"	v
debug	mycommand.h	/^   int debug;           \/\/!< if == 1, write out debug messages$/;"	m	struct:CommandSt
dense2sparseTimer	performance.h	/^   dense2sparseTimer,$/;"	e	enum:TimerHandle
destroyDecomposition	decomposition.c	/^void destroyDecomposition(struct DomainSt* domain)$/;"	f
destroyHaloExchange	haloExchange.c	/^void destroyHaloExchange(struct HaloExchangeSt* haloExchange)$/;"	f
destroyParallel	parallel.c	/^void destroyParallel()$/;"	f
destroySparseMatrix	sparseMatrix.c	/^void destroySparseMatrix(struct SparseMatrixSt* spmatrix)$/;"	f
dout	mycommand.h	/^   int dout;            \/\/!< if == 1, write out density matrix$/;"	m	struct:CommandSt
dupString	cmdLineParser.c	/^static char* dupString(const char* s)$/;"	f	file:
elapsed	performance.c	/^   uint64_t elapsed;   \/\/!< lap time$/;"	m	struct:TimersSt	file:
eps	constants.h	/^real_t eps; $/;"	v
eps	mycommand.h	/^   real_t eps;          \/\/!< threshold for sparse math $/;"	m	struct:CommandSt
exchangeData	haloExchange.c	/^void exchangeData(struct HaloExchangeSt* haloExchange, struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
exchangeSetup	haloExchange.c	/^void exchangeSetup(struct HaloExchangeSt* haloExchange, struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
exchangeTimer	performance.h	/^   exchangeTimer,$/;"	e	enum:TimerHandle
findOption	cmdLineParser.c	/^static MyOption* findOption(MyOption* o, unsigned char shortArg)$/;"	f	file:
freeArgs	cmdLineParser.c	/^void freeArgs()$/;"	f
gasdev	random.c	/^real_t gasdev(uint64_t* seed)$/;"	f
gatherData	haloExchange.c	/^void gatherData(struct HaloExchangeSt* haloExchange, struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
gen	mycommand.h	/^   int gen;             \/\/!< if == 1, generate sparse hamiltonian$/;"	m	struct:CommandSt
generateHMatrix	generate.c	/^SparseMatrix* generateHMatrix(int N, int M, real_t a, real_t alpha)$/;"	f
gershgorin	sparseMatrix.c	/^void gershgorin(struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
getElapsedTime	performance.c	/^double getElapsedTime(const enum TimerHandle handle)$/;"	f
getMyRank	parallel.c	/^int getMyRank()   $/;"	f
getNRanks	parallel.c	/^int getNRanks()$/;"	f
getTick	performance.c	/^static double getTick(void)$/;"	f	file:
getTime	performance.c	/^static uint64_t getTime(void)$/;"	f	file:
globalRowExtent	decomposition.h	/^   int globalRowExtent;   \/\/!< total global rows$/;"	m	struct:DomainSt
globalRowMax	decomposition.h	/^   int globalRowMax;      \/\/!< maximum global row number$/;"	m	struct:DomainSt
globalRowMin	decomposition.h	/^   int globalRowMin;      \/\/!< minimum global row number$/;"	m	struct:DomainSt
hDim	constants.h	/^int hDim;$/;"	v
hEps	constants.h	/^real_t hEps; $/;"	v
haloCount	haloExchange.h	/^  int haloCount;   \/\/!< number of processors to send\/reeive$/;"	m	struct:HaloExchangeSt
haloProc	haloExchange.h	/^  int* haloProc;   \/\/!< array of halo procs to send\/receive$/;"	m	struct:HaloExchangeSt
help	cmdLineParser.c	/^   char* help;$/;"	m	struct:MyOptionSt	file:
heps	mycommand.h	/^   real_t heps;         \/\/!< threshold for dense->sparse conversion$/;"	m	struct:CommandSt
hmatName	mycommand.h	/^   char hmatName[1024]; \/\/!< name of the dense H matrix file$/;"	m	struct:CommandSt
hsize	sparseMatrix.h	/^  int hsize;          \/\/!< denotes size of dense matrix would be hsize x hsize$/;"	m	struct:SparseMatrixSt
icol	haloExchange.c	/^   int icol;$/;"	m	struct:NonZeroMsgSt	file:
idemTol	constants.h	/^real_t idemTol; $/;"	v
idemTol	mycommand.h	/^   real_t idemTol;      \/\/!< threshold for SP2 loop$/;"	m	struct:CommandSt
iia	sparseMatrix.h	/^  int* iia;           \/\/!< ELLPACK-R vector containing number of non-zero elements per row$/;"	m	struct:SparseMatrixSt
initDecomposition	decomposition.c	/^Domain* initDecomposition(int nprocs, int nrows, int ncols)$/;"	f
initHaloExchange	haloExchange.c	/^HaloExchange* initHaloExchange(struct DomainSt* domain)$/;"	f
initParallel	parallel.c	/^void initParallel(int* argc, char*** argv)$/;"	f
initSimulation	CoSP2.c	/^SparseMatrix* initSimulation(Command cmd)$/;"	f
initSparseMatrix	sparseMatrix.c	/^SparseMatrix* initSparseMatrix(int hsize, int msize)$/;"	f
irecvAnyParallel	parallel.c	/^int irecvAnyParallel(void* recvBuf, int recvLen)$/;"	f
irecvParallel	parallel.c	/^int irecvParallel(void* recvBuf, int recvLen, int source)$/;"	f
irow	haloExchange.c	/^   int irow;$/;"	m	struct:NonZeroMsgSt	file:
isHaloProc	haloExchange.c	/^int isHaloProc(struct HaloExchangeSt* haloExchange, int rproc)$/;"	f
isendParallel	parallel.c	/^int isendParallel(void* sendBuf, int sendLen, int dest)$/;"	f
jja	sparseMatrix.h	/^  int** jja;          \/\/!< ELLPACK-R 2-D array containing indeces of values per row$/;"	m	struct:SparseMatrixSt
jjcontig	sparseMatrix.h	/^  int*  jjcontig;     \/\/!< 1-D array mapping to jja$/;"	m	struct:SparseMatrixSt
lastOption	cmdLineParser.c	/^static MyOption* lastOption(MyOption* o)$/;"	f	file:
lcg61	random.c	/^double lcg61(uint64_t* seed)$/;"	f
loadBuffer	haloExchange.c	/^int loadBuffer(char* buf, struct SparseMatrixSt* xmatrix, struct DomainSt* domain)$/;"	f
localRowExtent	decomposition.h	/^   int localRowExtent;    \/\/!< localRowMax - localRowMin$/;"	m	struct:DomainSt
localRowMax	decomposition.h	/^   int localRowMax;       \/\/!< maximum row on local processor$/;"	m	struct:DomainSt
localRowMin	decomposition.h	/^   int localRowMin;       \/\/!< minimum row on local processor$/;"	m	struct:DomainSt
longArg	cmdLineParser.c	/^   char* longArg;$/;"	m	struct:MyOptionSt	file:
longest	cmdLineParser.c	/^static int longest = 1;$/;"	v	file:
loopTimer	performance.h	/^   loopTimer,$/;"	e	enum:TimerHandle
main	CoSP2.c	/^int main(int argc, char** argv)$/;"	f
maxEval	sparseMatrix.h	/^  real_t maxEval;     \/\/!< max Gershgorin limit$/;"	m	struct:SparseMatrixSt
maxHalo	haloExchange.h	/^  int maxHalo;     \/\/!< max number of processors for halo$/;"	m	struct:HaloExchangeSt
maxIntParallel	parallel.c	/^void maxIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
maxIntReduce2	parallel.c	/^void maxIntReduce2(int* value0, int* value1)$/;"	f
maxMinusMin	sparseMatrix.h	/^  real_t maxMinusMin; \/\/!< max-min difference$/;"	m	struct:SparseMatrixSt
maxRank	performance.c	/^   int maxRank;        \/\/!< rank with max value$/;"	m	struct:CounterSt	file:
maxRank	performance.c	/^   int maxRank;        \/\/!< rank with max value$/;"	m	struct:TimersSt	file:
maxRankDoubleParallel	parallel.c	/^void maxRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
maxRealParallel	parallel.c	/^void maxRealParallel(real_t* sendBuf, real_t* recvBuf, int count)$/;"	f
maxRealReduce	parallel.c	/^void maxRealReduce(real_t* value)$/;"	f
maxValue	performance.c	/^   double maxValue;    \/\/!< max over ranks$/;"	m	struct:CounterSt	file:
maxValue	performance.c	/^   double maxValue;    \/\/!< max over ranks$/;"	m	struct:TimersSt	file:
minEval	sparseMatrix.h	/^  real_t minEval;     \/\/!< min Gershgorin limit$/;"	m	struct:SparseMatrixSt
minRank	performance.c	/^   int minRank;        \/\/!< rank with min value$/;"	m	struct:CounterSt	file:
minRank	performance.c	/^   int minRank;        \/\/!< rank with min value$/;"	m	struct:TimersSt	file:
minRankDoubleParallel	parallel.c	/^void minRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
minRealParallel	parallel.c	/^void minRealParallel(real_t* sendBuf, real_t* recvBuf, int count)$/;"	f
minRealReduce	parallel.c	/^void minRealReduce(real_t* value)$/;"	f
minValue	performance.c	/^   double minValue;    \/\/!< min over ranks$/;"	m	struct:CounterSt	file:
minValue	performance.c	/^   double minValue;    \/\/!< min over ranks$/;"	m	struct:TimersSt	file:
mkSeed	random.c	/^uint64_t mkSeed(uint32_t id, uint32_t callSite)$/;"	f
msize	sparseMatrix.h	/^  int msize;          \/\/!< max number of non-zeroes per row$/;"	m	struct:SparseMatrixSt
msparse	constants.h	/^int msparse;$/;"	v
myOptionAlloc	cmdLineParser.c	/^static MyOption* myOptionAlloc($/;"	f	file:
myOptionFree	cmdLineParser.c	/^static MyOption* myOptionFree(MyOption* o)$/;"	f	file:
myRank	parallel.c	/^static int myRank = 0;$/;"	v	file:
myargs	cmdLineParser.c	/^static MyOption* myargs=NULL;$/;"	v	file:
nRanks	parallel.c	/^static int nRanks = 1;$/;"	v	file:
next	cmdLineParser.c	/^   void* next;$/;"	m	struct:MyOptionSt	file:
nextOption	cmdLineParser.c	19;"	d	file:
nnzStart	sparseMatrix.c	/^int nnzStart(int hsize, int msize)$/;"	f
normTimer	performance.h	/^   normTimer,$/;"	e	enum:TimerHandle
normalize	sparseMatrix.c	/^void normalize(struct SparseMatrixSt* spmatrix)$/;"	f
numberOfCounters	performance.h	/^   numberOfCounters};$/;"	e	enum:CounterHandle
numberOfTimers	performance.h	/^   numberOfTimers};$/;"	e	enum:TimerHandle
oneMB	performance.c	/^static const int oneMB = 1024*1024;$/;"	v	file:
parseCommandLine	mycommand.c	/^Command parseCommandLine(int argc, char** argv)$/;"	f
perfCounter	performance.c	/^static Counter perfCounter[numberOfCounters];$/;"	v	file:
perfGlobal	performance.c	/^static TimerGlobal perfGlobal;$/;"	v	file:
perfTimer	performance.c	/^static Timers perfTimer[numberOfTimers];$/;"	v	file:
performanceStats	performance.c	/^void performanceStats(void)$/;"	f
postTimer	performance.h	/^   postTimer,$/;"	e	enum:TimerHandle
preTimer	performance.h	/^   preTimer,$/;"	e	enum:TimerHandle
printArgs	cmdLineParser.c	/^void printArgs()$/;"	f
printPerformanceResults	performance.c	/^void printPerformanceResults(int nGlobalAtoms, int printRate)$/;"	f
printPerformanceResultsYaml	performance.c	/^void printPerformanceResultsYaml(FILE* file)$/;"	f
printRank	parallel.c	/^int printRank()$/;"	f
processArgs	cmdLineParser.c	/^void processArgs(int argc, char** argv)$/;"	f
processorNum	decomposition.c	/^int processorNum(Domain* domain, int rnum)$/;"	f
profileStart	performance.c	/^void profileStart(const enum TimerHandle handle)$/;"	f
profileStop	performance.c	/^void profileStop(const enum TimerHandle handle)$/;"	f
ptr	cmdLineParser.c	/^   void* ptr;$/;"	m	struct:MyOptionSt	file:
rUsed	parallel.c	/^static int* rUsed;$/;"	v	file:
rank	parallel.h	/^   int rank;$/;"	m	struct:RankReduceDataSt
readMTX	matrixio.c	/^void readMTX(char* fname, struct SparseMatrixSt* hmatrix)$/;"	f
readhTimer	performance.h	/^   readhTimer,$/;"	e	enum:TimerHandle
real3	mytype.h	/^typedef real_t real3[3]; \/\/!< a convenience vector with three real_t $/;"	t
real_t	mytype.h	/^typedef double real_t; \/\/!< define native type for CoMD as double precision$/;"	t
real_t	mytype.h	/^typedef float real_t;  \/\/!< define native type for CoMD as single precision$/;"	t
recvAnyParallel	parallel.c	/^int recvAnyParallel(void* recvBuf, int recvLen)$/;"	f
recvBuf	haloExchange.h	/^  char** recvBuf;  \/\/!< recv buffer$/;"	m	struct:HaloExchangeSt
recvCounter	performance.h	/^   recvCounter,$/;"	e	enum:CounterHandle
recvParallel	parallel.c	/^int recvParallel(void* recvBuf, int recvLen, int source)$/;"	f
reduceCommTimer	performance.h	/^   reduceCommTimer,$/;"	e	enum:TimerHandle
reduceCounter	performance.h	/^   reduceCounter,$/;"	e	enum:CounterHandle
reportResults	sp2Loop.c	/^void reportResults(int iter, struct SparseMatrixSt* xmatrix, struct SparseMatrixSt* x2matrix, struct DomainSt* domain)$/;"	f
reqCount	parallel.c	/^static int reqCount = 0;$/;"	v	file:
requestList	parallel.c	/^static MPI_Request* requestList;$/;"	v	file:
rlist	haloExchange.h	/^  int* rlist;      \/\/!< array of request indeces for non-blocking receives$/;"	m	struct:HaloExchangeSt
saveRequest	parallel.c	/^int saveRequest(MPI_Request req)$/;"	f
screenOut	mytype.h	27;"	d
sendBuf	haloExchange.h	/^  char* sendBuf;   \/\/!< send buffer$/;"	m	struct:HaloExchangeSt
sendCounter	performance.h	/^   sendCounter,$/;"	e	enum:CounterHandle
sendParallel	parallel.c	/^int sendParallel(void* sendBuf, int sendLen, int dest)$/;"	f
sendReceiveParallel	parallel.c	/^int sendReceiveParallel(void* sendBuf, int sendLen, int dest,$/;"	f
shortArg	cmdLineParser.c	/^   unsigned char shortArg[2];$/;"	m	struct:MyOptionSt	file:
sp2Loop	sp2Loop.c	/^void sp2Loop(struct SparseMatrixSt* xmatrix, struct DomainSt* domain)$/;"	f
sp2LoopTimer	performance.h	/^   sp2LoopTimer, $/;"	e	enum:TimerHandle
sparse2denseTimer	performance.h	/^   sparse2denseTimer,$/;"	e	enum:TimerHandle
sparseAdd	sparseMath.c	/^void sparseAdd(struct SparseMatrixSt* xmatrix, struct SparseMatrixSt* x2matrix, struct DomainSt* domain)$/;"	f
sparseMultScalar	sparseMath.c	/^void sparseMultScalar(struct SparseMatrixSt* xmatrix, struct DomainSt* domain, real_t scalar)$/;"	f
sparseSetX2	sparseMath.c	/^void sparseSetX2(struct SparseMatrixSt* xmatrix, struct SparseMatrixSt* x2matrix, struct DomainSt* domain)$/;"	f
sparseX2	sparseMath.c	/^void sparseX2(real_t* trX, real_t* trX2, struct SparseMatrixSt* xmatrix, struct SparseMatrixSt* x2matrix, struct DomainSt* domain)$/;"	f
sparsity	sparseMatrix.c	/^void sparsity(struct SparseMatrixSt* spmatrix)$/;"	f
start	performance.c	/^   uint64_t start;     \/\/!< call start time$/;"	m	struct:TimersSt	file:
startTimer	performance.h	41;"	d
startTimer	performance.h	52;"	d
stdev	performance.c	/^   double stdev;       \/\/!< stdev across ranks$/;"	m	struct:CounterSt	file:
stdev	performance.c	/^   double stdev;       \/\/!< stdev across ranks$/;"	m	struct:TimersSt	file:
stopTimer	performance.h	46;"	d
stopTimer	performance.h	53;"	d
sz	cmdLineParser.c	/^   int sz;$/;"	m	struct:MyOptionSt	file:
testIrecv	parallel.c	/^int testIrecv(int rind)$/;"	f
testIsend	parallel.c	/^int testIsend(int rind)$/;"	f
timerName	performance.c	/^char* timerName[numberOfTimers] = {$/;"	v
timestampBarrier	parallel.c	/^void timestampBarrier(const char* msg)$/;"	f
total	performance.c	/^   uint64_t total;     \/\/!< current total time$/;"	m	struct:TimersSt	file:
total	performance.c	/^   uint64_t total;     \/\/!< sum of values$/;"	m	struct:CounterSt	file:
totalCols	decomposition.h	/^   int totalCols;         \/\/!< number of non-zero columns per row$/;"	m	struct:DomainSt
totalProcs	decomposition.h	/^   int totalProcs;        \/\/!< number of processors$/;"	m	struct:DomainSt
totalRows	decomposition.h	/^   int totalRows;         \/\/!< total number of rows$/;"	m	struct:DomainSt
totalTimer	performance.h	/^   totalTimer, $/;"	e	enum:TimerHandle
trace	sparseMatrix.c	/^void trace(struct SparseMatrixSt* spmatrix, struct DomainSt* domain, real_t* tr, real_t* tr2)$/;"	f
type	cmdLineParser.c	/^   char type;$/;"	m	struct:MyOptionSt	file:
unloadBuffer	haloExchange.c	/^void unloadBuffer(char* buf, int bufSize, struct SparseMatrixSt* xmatrix, struct DomainSt* domain)$/;"	f
updateData	haloExchange.c	/^void updateData(struct HaloExchangeSt* haloExchange, struct SparseMatrixSt* spmatrix, struct DomainSt* domain)$/;"	f
val	haloExchange.c	/^   real_t val;$/;"	m	struct:NonZeroMsgSt	file:
val	parallel.h	/^   double val;$/;"	m	struct:RankReduceDataSt
val	sparseMatrix.h	/^  real_t** val;       \/\/!< ELLPACK-R 2-D array containing non-zero elements by row$/;"	m	struct:SparseMatrixSt
valcontig	sparseMatrix.h	/^  real_t*  valcontig; \/\/!< 1-D array mapping to val$/;"	m	struct:SparseMatrixSt
waitIrecv	parallel.c	/^int waitIrecv(int rind)$/;"	f
waitIsend	parallel.c	/^int waitIsend(int rind)$/;"	f
writeMTX	matrixio.c	/^void writeMTX(char* fname, struct SparseMatrixSt* spmatrix)$/;"	f
writeSparsePattern	matrixio.c	/^void writeSparsePattern(char* fname, struct SparseMatrixSt* spmatrix, real_t hthresh)$/;"	f
x2Timer	performance.h	/^   x2Timer,$/;"	e	enum:TimerHandle
xaddTimer	performance.h	/^   xaddTimer,$/;"	e	enum:TimerHandle
xsetTimer	performance.h	/^   xsetTimer,$/;"	e	enum:TimerHandle
zeroReal3	mytype.h	/^static void zeroReal3(real3 a)$/;"	f
