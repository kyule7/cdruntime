!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AngsInMeters	constants.h	22;"	d
AtomExchangeParms	haloExchange.c	/^AtomExchangeParms;$/;"	t	typeref:struct:AtomExchangeParmsSt	file:
AtomExchangeParmsSt	haloExchange.c	/^typedef struct AtomExchangeParmsSt$/;"	s	file:
AtomMsg	haloExchange.c	/^AtomMsg;$/;"	t	typeref:struct:AtomMsgSt	file:
AtomMsgSt	haloExchange.c	/^typedef struct AtomMsgSt$/;"	s	file:
Atoms	initAtoms.h	/^} Atoms;$/;"	t	typeref:struct:AtomsSt
AtomsSt	initAtoms.h	/^typedef struct AtomsSt$/;"	s
BIN_DIR	Makefile	/^BIN_DIR=..\/bin$/;"	m
BasePotential	CoMDTypes.h	/^} BasePotential;$/;"	t	typeref:struct:BasePotentialSt
BasePotentialSt	CoMDTypes.h	/^typedef struct BasePotentialSt $/;"	s
CC	Makefile	/^CC = mpicc$/;"	m
CD_CFLAGS	Makefile	/^CD_CFLAGS = -I$(CD_ROOT)\/include $/;"	m
CD_LINKFLAGS	Makefile	/^CD_LINKFLAGS = -L$(CD_ROOT)\/lib -lcd -Wl,-rpath=..\/..\/..\/lib -L$(CD_ROOT)\/src\/persistence -lpacker$/;"	m
CD_ROOT	Makefile	/^CD_ROOT=${CD_PATH}$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=gnu11$/;"	m
CMDLINEPARSER_H_	cmdLineParser.h	8;"	d
C_LIB	Makefile	/^C_LIB = -lm$/;"	m
CoMDVariant	yamlOutput.c	/^static const char* CoMDVariant = CoMD_VARIANT;$/;"	v	file:
CoMDVersion	yamlOutput.c	/^static const char* CoMDVersion = "1.1";$/;"	v	file:
CoMD_EXE	Makefile	/^CoMD_EXE = ${BIN_DIR}\/${CoMD_VARIANT}$/;"	m
CoMD_VARIANT	Makefile	/^CoMD_VARIANT = CoMD-mpi$/;"	m
CoMD_VARIANT	Makefile	/^CoMD_VARIANT = CoMD-serial$/;"	m
Command	mycommand.h	/^} Command;$/;"	t	typeref:struct:CommandSt
CommandSt	mycommand.h	/^typedef struct CommandSt$/;"	s
DOUBLE_PRECISION	Makefile	/^DOUBLE_PRECISION = ON$/;"	m
DO_MPI	Makefile	/^DO_MPI = ON$/;"	m
Domain	decomposition.h	/^} Domain;$/;"	t	typeref:struct:DomainSt
DomainSt	decomposition.h	/^typedef struct DomainSt$/;"	s
EMT1	mytype.h	11;"	d
EMT1	mytype.h	15;"	d
EamPotential	eam.c	/^} EamPotential;$/;"	t	typeref:struct:EamPotentialSt	file:
EamPotentialSt	eam.c	/^typedef struct EamPotentialSt $/;"	s	file:
FMT1	mytype.h	10;"	d
FMT1	mytype.h	14;"	d
ForceExchangeData	eam.h	/^}ForceExchangeData;$/;"	t	typeref:struct:ForceExchangeDataSt
ForceExchangeDataSt	eam.h	/^typedef struct ForceExchangeDataSt$/;"	s
ForceExchangeParms	haloExchange.c	/^ForceExchangeParms;$/;"	t	typeref:struct:ForceExchangeParmsSt	file:
ForceExchangeParmsSt	haloExchange.c	/^typedef struct ForceExchangeParmsSt$/;"	s	file:
ForceMsg	haloExchange.c	/^ForceMsg;$/;"	t	typeref:struct:ForceMsgSt	file:
ForceMsgSt	haloExchange.c	/^typedef struct ForceMsgSt$/;"	s	file:
HALO_X_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_X_MINUS	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_X_PLUS	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Y_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_Y_MINUS	haloExchange.c	/^                    HALO_Y_MINUS, HALO_Y_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Y_PLUS	haloExchange.c	/^                    HALO_Y_MINUS, HALO_Y_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Z_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_Z_MINUS	haloExchange.c	/^                    HALO_Z_MINUS, HALO_Z_PLUS};$/;"	e	enum:HaloFaceOrder	file:
HALO_Z_PLUS	haloExchange.c	/^                    HALO_Z_MINUS, HALO_Z_PLUS};$/;"	e	enum:HaloFaceOrder	file:
HaloAxisOrder	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	g	file:
HaloExchange	haloExchange.h	/^HaloExchange;$/;"	t	typeref:struct:HaloExchangeSt
HaloExchangeSt	haloExchange.h	/^typedef struct HaloExchangeSt$/;"	s
HaloFaceOrder	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	g	file:
INCLUDES	Makefile	/^INCLUDES = $/;"	m
InterpolationObject	eam.c	/^} InterpolationObject;$/;"	t	typeref:struct:InterpolationObjectSt	file:
InterpolationObjectSt	eam.c	/^typedef struct InterpolationObjectSt $/;"	s	file:
LinkCell	linkCells.h	/^} LinkCell;$/;"	t	typeref:struct:LinkCellSt
LinkCellSt	linkCells.h	/^typedef struct LinkCellSt$/;"	s
LjPotential	ljForce.c	/^} LjPotential;$/;"	t	typeref:struct:LjPotentialSt	file:
LjPotentialSt	ljForce.c	/^typedef struct LjPotentialSt$/;"	s	file:
MAX	eam.c	103;"	d	file:
MAX	haloExchange.c	45;"	d	file:
MAX	linkCells.c	76;"	d	file:
MAXATOMS	linkCells.h	10;"	d
MIN	CoMD.c	68;"	d	file:
MIN	linkCells.c	75;"	d	file:
MPI_INCLUDE	Makefile	/^MPI_INCLUDE =$/;"	m
MPI_LIB	Makefile	/^MPI_LIB =$/;"	m
MYCOMMAND_H	mycommand.h	5;"	d
MyOption	cmdLineParser.c	/^} MyOption;$/;"	t	typeref:struct:MyOptionSt	file:
MyOptionSt	cmdLineParser.c	/^typedef struct MyOptionSt$/;"	s	file:
OBJECTS	Makefile	/^OBJECTS=$(SOURCES:.c=.o)$/;"	m
OPTFLAGS	Makefile	/^OPTFLAGS = -g -O5$/;"	m
OTHER_INCLUDE	Makefile	/^OTHER_INCLUDE =$/;"	m
OTHER_LIB	Makefile	/^OTHER_LIB =$/;"	m
POT_SHIFT	ljForce.c	75;"	d	file:
REAL_MPI_TYPE	parallel.c	28;"	d	file:
REAL_MPI_TYPE	parallel.c	30;"	d	file:
REDIRECT_OUTPUT	CoMD.c	67;"	d	file:
RankReduceData	parallel.h	/^} RankReduceData;$/;"	t	typeref:struct:RankReduceDataSt
RankReduceDataSt	parallel.h	/^typedef struct RankReduceDataSt$/;"	s
SHELL	Makefile	/^SHELL = \/bin\/bash$/;"	m
SOURCES	Makefile	/^SOURCES=$(wildcard *.c)$/;"	m
SimFlat	CoMDTypes.h	/^} SimFlat;$/;"	t	typeref:struct:SimFlatSt
SimFlatSt	CoMDTypes.h	/^typedef struct SimFlatSt$/;"	s
SpeciesData	CoMDTypes.h	/^} SpeciesData;$/;"	t	typeref:struct:SpeciesDataSt
SpeciesDataSt	CoMDTypes.h	/^typedef struct SpeciesDataSt$/;"	s
TimerGlobal	performanceTimers.c	/^} TimerGlobal;$/;"	t	typeref:struct:TimerGlobalSt	file:
TimerGlobalSt	performanceTimers.c	/^typedef struct TimerGlobalSt$/;"	s	file:
TimerHandle	performanceTimers.h	/^enum TimerHandle{$/;"	g
Timers	performanceTimers.c	/^} Timers;$/;"	t	typeref:struct:TimersSt	file:
TimersSt	performanceTimers.c	/^typedef struct TimersSt$/;"	s	file:
U	initAtoms.h	/^   real_t* U;     \/\/!< potential energy per atom$/;"	m	struct:AtomsSt
Validate	CoMDTypes.h	/^} Validate;$/;"	t	typeref:struct:ValidateSt
ValidateSt	CoMDTypes.h	/^typedef struct ValidateSt$/;"	s
_CONSTANTS_H_	constants.h	13;"	d
_GEOMETRY_H_	decomposition.h	5;"	d
_LJTYPES_H_	ljForce.h	5;"	d
_MEMUTILS_H_	memUtils.h	5;"	d
_PARALLEL_H_	parallel.h	5;"	d
__COMDTYPES_H_	CoMDTypes.h	5;"	d
__EAM_H	eam.h	5;"	d
__HALO_EXCHANGE_	haloExchange.h	5;"	d
__INIT_ATOMS_H	initAtoms.h	5;"	d
__LEAPFROG_H	timestep.h	5;"	d
__LINK_CELLS_H_	linkCells.h	5;"	d
__MYTYPE_H_	mytype.h	5;"	d
__PERFORMANCE_TIMERS_H_	performanceTimers.h	4;"	d
__RANDOM_H	random.h	6;"	d
__STDC_FORMAT_MACROS	performanceTimers.h	5;"	d
__YAML_OUTPUT_H	yamlOutput.h	5;"	d
addArg	cmdLineParser.c	/^int addArg(const char* longOption, const char shortOption,$/;"	f
addDoubleParallel	parallel.c	/^void addDoubleParallel(double* sendBuf, double* recvBuf, int count)$/;"	f
addIntParallel	parallel.c	/^void addIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
addRealParallel	parallel.c	/^void addRealParallel(real_t* sendBuf, real_t* recvBuf, int count)$/;"	f
advancePosition	timestep.c	/^void advancePosition(SimFlat* s, int nBoxes, real_t dt)$/;"	f
advanceVelocity	timestep.c	/^void advanceVelocity(SimFlat* s, int nBoxes, real_t dt)$/;"	f
amuInKilograms	constants.h	16;"	d
amuToInternalMass	constants.h	/^static const double amuToInternalMass =$/;"	v
argFlag	cmdLineParser.c	/^   int argFlag;$/;"	m	struct:MyOptionSt	file:
atomAllRate	performanceTimers.c	/^   double atomAllRate;    \/\/!< average time (us) per atom$/;"	m	struct:TimerGlobalSt	file:
atomExchange	CoMDTypes.h	/^   HaloExchange* atomExchange;$/;"	m	struct:SimFlatSt
atomHaloTimer	performanceTimers.h	/^   atomHaloTimer, $/;"	e	enum:TimerHandle
atomRate	performanceTimers.c	/^   double atomRate;       \/\/!< average time (us) per atom per rank $/;"	m	struct:TimerGlobalSt	file:
atomicNo	CoMDTypes.h	/^   int	 atomicNo;	   \/\/!< atomic number  $/;"	m	struct:BasePotentialSt
atomicNo	CoMDTypes.h	/^   int	 atomicNo;  \/\/!< atomic number  $/;"	m	struct:SpeciesDataSt
atomicNo	eam.c	/^   int	 atomicNo;	   \/\/!< atomic number  $/;"	m	struct:EamPotentialSt	file:
atomicNo	ljForce.c	/^   int	 atomicNo;	   \/\/!< atomic number  $/;"	m	struct:LjPotentialSt	file:
atoms	CoMDTypes.h	/^   Atoms* atoms;          \/\/<! atom data (positions, momenta, ...)$/;"	m	struct:SimFlatSt
atomsPerUSec	performanceTimers.c	/^   double atomsPerUSec;   \/\/!< average atoms per time (us)$/;"	m	struct:TimerGlobalSt	file:
average	performanceTimers.c	/^   double average;     \/\/!< average over ranks$/;"	m	struct:TimersSt	file:
barrierParallel	parallel.c	/^void barrierParallel()$/;"	f
bcastInterpolationObject	eam.c	/^void bcastInterpolationObject(InterpolationObject** table)$/;"	f
bcastParallel	parallel.c	/^void bcastParallel(void* buf, int count, int root)$/;"	f
bohrToAngs	constants.h	/^static const double bohrToAngs = 0.52917721092;$/;"	v
boxSize	linkCells.h	/^   real3 boxSize;       \/\/!< size of box in each dimension$/;"	m	struct:LinkCellSt
boxes	CoMDTypes.h	/^   LinkCell* boxes;       \/\/<! link-cell data$/;"	m	struct:SimFlatSt
boxes	eam.h	/^   struct LinkCellSt* boxes;$/;"	m	struct:ForceExchangeDataSt	typeref:struct:ForceExchangeDataSt::LinkCellSt
bufCapacity	haloExchange.h	/^   int bufCapacity;$/;"	m	struct:HaloExchangeSt
builtWithMpi	parallel.c	/^int builtWithMpi(void)$/;"	f
cellList	haloExchange.c	/^   int* cellList[6];     \/\/!< List of link cells from which to load data for each face.$/;"	m	struct:AtomExchangeParmsSt	file:
comdCalloc	memUtils.h	/^static void* comdCalloc(size_t num, size_t iSize)$/;"	f
comdFree	memUtils.h	/^static void comdFree(void *ptr)$/;"	f
comdMalloc	memUtils.h	/^static void* comdMalloc(size_t iSize)$/;"	f
comdRealloc	memUtils.h	/^static void* comdRealloc(void* ptr, size_t iSize)$/;"	f
commHaloTimer	performanceTimers.h	/^   commHaloTimer, $/;"	e	enum:TimerHandle
commReduceTimer	performanceTimers.h	/^   commReduceTimer, $/;"	e	enum:TimerHandle
computeForce	timestep.c	/^void computeForce(SimFlat* s)$/;"	f
computeForceTimer	performanceTimers.h	/^   computeForceTimer, $/;"	e	enum:TimerHandle
computeVcm	initAtoms.c	/^void computeVcm(SimFlat* s, real_t vcm[3])$/;"	f
copyAtom	linkCells.c	/^void copyAtom(LinkCell* boxes, Atoms* atoms, int iAtom, int iBox, int jAtom, int jBox)$/;"	f
count	performanceTimers.c	/^   uint64_t count;     \/\/!< current call count$/;"	m	struct:TimersSt	file:
createFccLattice	initAtoms.c	/^void createFccLattice(int nx, int ny, int nz, real_t lat, SimFlat* s)$/;"	f
cutoff	CoMDTypes.h	/^   real_t cutoff;          \/\/!< potential cutoff distance in Angstroms$/;"	m	struct:BasePotentialSt
cutoff	eam.c	/^   real_t cutoff;          \/\/!< potential cutoff distance in Angstroms$/;"	m	struct:EamPotentialSt	file:
cutoff	ljForce.c	/^   real_t cutoff;          \/\/!< potential cutoff distance in Angstroms$/;"	m	struct:LjPotentialSt	file:
destroy	CoMDTypes.h	/^   void (*destroy)(struct BasePotentialSt** pot); \/\/!< destruction of the potential$/;"	m	struct:BasePotentialSt
destroy	eam.c	/^   void (*destroy)(BasePotential** pot); \/\/!< destruction of the potential$/;"	m	struct:EamPotentialSt	file:
destroy	haloExchange.h	/^   void (*destroy)(void* parms);$/;"	m	struct:HaloExchangeSt
destroy	ljForce.c	/^   void (*destroy)(BasePotential** pot); \/\/!< destruction of the potential$/;"	m	struct:LjPotentialSt	file:
destroyAtoms	initAtoms.c	/^void destroyAtoms(Atoms *atoms)$/;"	f
destroyAtomsExchange	haloExchange.c	/^void destroyAtomsExchange(void* vparms)$/;"	f
destroyForceExchange	haloExchange.c	/^void destroyForceExchange(void* vparms)$/;"	f
destroyHaloExchange	haloExchange.c	/^void destroyHaloExchange(HaloExchange** haloExchange)$/;"	f
destroyInterpolationObject	eam.c	/^void destroyInterpolationObject(InterpolationObject** a)$/;"	f
destroyLinkCells	linkCells.c	/^void destroyLinkCells(LinkCell** boxes)$/;"	f
destroyParallel	parallel.c	/^void destroyParallel()$/;"	f
destroySimulation	CoMD.c	/^void destroySimulation(SimFlat** ps)$/;"	f
dfEmbed	eam.c	/^   real_t* dfEmbed;       \/\/!< per atom storage for derivative of Embedding$/;"	m	struct:EamPotentialSt	file:
dfEmbed	eam.h	/^   real_t* dfEmbed; \/\/<! derivative of embedding energy$/;"	m	struct:ForceExchangeDataSt
dfEmbed	haloExchange.c	/^   real_t dfEmbed;$/;"	m	struct:ForceMsgSt	file:
doeam	mycommand.h	/^   int doeam;          \/\/!< a flag to determine whether we're running EAM potentials$/;"	m	struct:CommandSt
domain	CoMDTypes.h	/^   Domain* domain;        \/\/<! domain decomposition data$/;"	m	struct:SimFlatSt
dt	CoMDTypes.h	/^   double dt;             \/\/<! time step$/;"	m	struct:SimFlatSt
dt	mycommand.h	/^   double dt;          \/\/!< time step (in femtoseconds)$/;"	m	struct:CommandSt
dupString	cmdLineParser.c	/^static char* dupString(const char* s)$/;"	f	file:
eKinetic	CoMDTypes.h	/^   real_t eKinetic;       \/\/!< the total kinetic energy of the system$/;"	m	struct:SimFlatSt
ePotential	CoMDTypes.h	/^   real_t ePotential;     \/\/!< the total potential energy of the system$/;"	m	struct:SimFlatSt
eTot0	CoMDTypes.h	/^   double eTot0; \/\/<! Initial total energy$/;"	m	struct:ValidateSt
eVInJoules	constants.h	25;"	d
eamBcastPotential	eam.c	/^void eamBcastPotential(EamPotential* pot)$/;"	f
eamDestroy	eam.c	/^void eamDestroy(BasePotential** pPot)$/;"	f
eamForce	eam.c	/^int eamForce(SimFlat* s)$/;"	f
eamHaloTimer	performanceTimers.h	/^   eamHaloTimer, $/;"	e	enum:TimerHandle
eamPrint	eam.c	/^void eamPrint(FILE* file, BasePotential* pot)$/;"	f
eamReadFuncfl	eam.c	/^void eamReadFuncfl(EamPotential* pot, const char* dir, const char* potName)$/;"	f
eamReadSetfl	eam.c	/^void eamReadSetfl(EamPotential* pot, const char* dir, const char* potName)$/;"	f
elapsed	performanceTimers.c	/^   uint64_t elapsed;   \/\/!< lap time$/;"	m	struct:TimersSt	file:
emptyHaloCells	linkCells.c	/^void emptyHaloCells(LinkCell* boxes)$/;"	f
epsilon	ljForce.c	/^   real_t epsilon;$/;"	m	struct:LjPotentialSt	file:
exchangeData	haloExchange.c	/^void exchangeData(HaloExchange* haloExchange, void* data, int iAxis)$/;"	f
f	eam.c	/^   InterpolationObject* f;    \/\/!< Embedding Energy$/;"	m	struct:EamPotentialSt	file:
f	initAtoms.h	/^   real3*  f;     \/\/!< forces $/;"	m	struct:AtomsSt
fileNotFound	eam.c	/^void fileNotFound(const char* callSite, const char* filename)$/;"	f
finalizeSubsystems	CoMD.c	/^void finalizeSubsystems(void)$/;"	f
findOption	cmdLineParser.c	/^static MyOption* findOption(MyOption* o, unsigned char shortArg)$/;"	f	file:
force	CoMDTypes.h	/^   int  (*force)(struct SimFlatSt* s); \/\/!< function pointer to force routine$/;"	m	struct:BasePotentialSt
force	eam.c	/^   int  (*force)(SimFlat* s); \/\/!< function pointer to force routine$/;"	m	struct:EamPotentialSt	file:
force	ljForce.c	/^   int  (*force)(SimFlat* s); \/\/!< function pointer to force routine$/;"	m	struct:LjPotentialSt	file:
forceExchange	eam.c	/^   HaloExchange* forceExchange;$/;"	m	struct:EamPotentialSt	file:
forceExchangeData	eam.c	/^   ForceExchangeData* forceExchangeData;$/;"	m	struct:EamPotentialSt	file:
freeArgs	cmdLineParser.c	/^void freeArgs()$/;"	f
freeMe	memUtils.h	9;"	d
fsInSeconds	constants.h	19;"	d
gasdev	random.c	/^real_t gasdev(uint64_t* seed)$/;"	f
getBoxFromCoord	linkCells.c	/^int getBoxFromCoord(LinkCell* boxes, real_t rr[3])$/;"	f
getBoxFromTuple	linkCells.c	/^int getBoxFromTuple(LinkCell* boxes, int ix, int iy, int iz)$/;"	f
getElapsedTime	performanceTimers.c	/^double getElapsedTime(const enum TimerHandle handle)$/;"	f
getMyRank	parallel.c	/^int getMyRank()   $/;"	f
getNRanks	parallel.c	/^int getNRanks()$/;"	f
getNeighborBoxes	linkCells.c	/^int getNeighborBoxes(LinkCell* boxes, int iBox, int* nbrBoxes)$/;"	f
getTick	performanceTimers.c	/^static double getTick(void)$/;"	f	file:
getTime	performanceTimers.c	/^static uint64_t getTime(void)$/;"	f	file:
getTimeString	yamlOutput.c	/^static void getTimeString(char* timestring)$/;"	f	file:
getTuple	linkCells.c	/^void getTuple(LinkCell* boxes, int iBox, int* ixp, int* iyp, int* izp)$/;"	f
gid	haloExchange.c	/^   int gid;$/;"	m	struct:AtomMsgSt	file:
gid	initAtoms.h	/^   int* gid;      \/\/!< A globally unique id for each atom$/;"	m	struct:AtomsSt
globalExtent	decomposition.h	/^   real3 globalExtent;     \/\/!< global size: globalMax - globalMin$/;"	m	struct:DomainSt
globalMax	decomposition.h	/^   real3 globalMax;        \/\/!< maximum global coordinate (angstroms)$/;"	m	struct:DomainSt
globalMin	decomposition.h	/^   real3 globalMin;        \/\/!< minimum global coordinate (angstroms)$/;"	m	struct:DomainSt
gridSize	linkCells.h	/^   int gridSize[3];     \/\/!< number of boxes in each dimension on processor$/;"	m	struct:LinkCellSt
haloExchange	haloExchange.c	/^void haloExchange(HaloExchange* haloExchange, void* data)$/;"	f
hartreeToEv	constants.h	/^static const double hartreeToEv = 27.21138505;$/;"	v
help	cmdLineParser.c	/^   char* help;$/;"	m	struct:MyOptionSt	file:
iSpecies	initAtoms.h	/^   int* iSpecies; \/\/!< the species index of the atom$/;"	m	struct:AtomsSt
initAtomHaloExchange	haloExchange.c	/^HaloExchange* initAtomHaloExchange(Domain* domain, LinkCell* boxes)$/;"	f
initAtoms	initAtoms.c	/^Atoms* initAtoms(LinkCell* boxes)$/;"	f
initDecomposition	decomposition.c	/^Domain* initDecomposition(int xproc, int yproc, int zproc, real3 globalExtent)$/;"	f
initEamPot	eam.c	/^BasePotential* initEamPot(const char* dir, const char* file, const char* type)$/;"	f
initForceHaloExchange	haloExchange.c	/^HaloExchange* initForceHaloExchange(Domain* domain, LinkCell* boxes)$/;"	f
initHaloExchange	haloExchange.c	/^HaloExchange* initHaloExchange(Domain* domain)$/;"	f
initInterpolationObject	eam.c	/^InterpolationObject* initInterpolationObject($/;"	f
initLinkCells	linkCells.c	/^LinkCell* initLinkCells(const Domain* domain, real_t cutoff)$/;"	f
initLjPot	ljForce.c	/^BasePotential* initLjPot(void)$/;"	f
initParallel	parallel.c	/^void initParallel(int* argc, char*** argv)$/;"	f
initPotential	CoMD.c	/^BasePotential* initPotential($/;"	f
initSimulation	CoMD.c	/^SimFlat* initSimulation(Command cmd)$/;"	f
initSpecies	CoMD.c	/^SpeciesData* initSpecies(BasePotential* pot)$/;"	f
initSubsystems	CoMD.c	/^void initSubsystems(void)$/;"	f
initValidate	CoMD.c	/^Validate* initValidate(SimFlat* sim)$/;"	f
initialDelta	mycommand.h	/^   double initialDelta; \/\/!< magnitude of initial displacement from lattice (in Angstroms)$/;"	m	struct:CommandSt
interpolate	eam.c	/^void interpolate(InterpolationObject* table, real_t r, real_t* f, real_t* df)$/;"	f
invBoxSize	linkCells.h	/^   real3 invBoxSize;    \/\/!< inverse size of box in each dimension$/;"	m	struct:LinkCellSt
invDx	eam.c	/^   real_t invDx;   \/\/!< the inverse of the table spacing$/;"	m	struct:InterpolationObjectSt	file:
is_first	ljForce.c	/^int is_first = 0;$/;"	v
kB_eV	constants.h	/^static const double kB_eV = 8.6173324e-5;  \/\/ eV\/K$/;"	v
kineticEnergy	timestep.c	/^void kineticEnergy(SimFlat* s)$/;"	f
lastOption	cmdLineParser.c	/^static MyOption* lastOption(MyOption* o)$/;"	f	file:
lat	CoMDTypes.h	/^   real_t lat;             \/\/!< lattice spacing (angs) of unit cell$/;"	m	struct:BasePotentialSt
lat	eam.c	/^   real_t lat;             \/\/!< lattice spacing (angs) of unit cell$/;"	m	struct:EamPotentialSt	file:
lat	ljForce.c	/^   real_t lat;             \/\/!< lattice spacing (angs) of unit cell$/;"	m	struct:LjPotentialSt	file:
lat	mycommand.h	/^   double lat;         \/\/!< lattice constant (in Angstroms)$/;"	m	struct:CommandSt
latticeType	CoMDTypes.h	/^   char latticeType[8];    \/\/!< lattice type, e.g. FCC, BCC, etc.$/;"	m	struct:BasePotentialSt
latticeType	eam.c	/^   char latticeType[8];    \/\/!< lattice type, e.g. FCC, BCC, etc.$/;"	m	struct:EamPotentialSt	file:
latticeType	ljForce.c	/^   char latticeType[8];    \/\/!< lattice type, e.g. FCC, BCC, etc.$/;"	m	struct:LjPotentialSt	file:
lcg61	random.c	/^double lcg61(uint64_t* seed)$/;"	f
ljForce	ljForce.c	/^int ljForce(SimFlat* s)$/;"	f
ljPrint	ljForce.c	/^void ljPrint(FILE* file, BasePotential* pot)$/;"	f
ljcd_destroy	ljForce.c	/^void ljcd_destroy(BasePotential** inppot)$/;"	f
loadAtomsBuffer	haloExchange.c	/^int loadAtomsBuffer(void* vparms, void* data, int face, char* charBuf)$/;"	f
loadBuffer	haloExchange.h	/^   int  (*loadBuffer)(void* parms, void* data, int face, char* buf);$/;"	m	struct:HaloExchangeSt
loadForceBuffer	haloExchange.c	/^int loadForceBuffer(void* vparms, void* vdata, int face, char* charBuf)$/;"	f
localExtent	decomposition.h	/^   real3 localExtent;      \/\/!< localMax - localMin$/;"	m	struct:DomainSt
localMax	decomposition.h	/^   real3 localMax;         \/\/!< maximum coordinate on local processor$/;"	m	struct:DomainSt
localMax	linkCells.h	/^   real3 localMax;      \/\/!< maximum local bounds on processor$/;"	m	struct:LinkCellSt
localMin	decomposition.h	/^   real3 localMin;         \/\/!< minimum coordinate on local processor$/;"	m	struct:DomainSt
localMin	linkCells.h	/^   real3 localMin;      \/\/!< minimum local bounds on processor$/;"	m	struct:LinkCellSt
longArg	cmdLineParser.c	/^   char* longArg;$/;"	m	struct:MyOptionSt	file:
longest	cmdLineParser.c	/^static int longest = 1;$/;"	v	file:
loopTimer	performanceTimers.h	/^   loopTimer, $/;"	e	enum:TimerHandle
main	CoMD.c	/^int main(int argc, char** argv)$/;"	f
mass	CoMDTypes.h	/^   real_t mass;            \/\/!< mass of atoms in intenal units$/;"	m	struct:BasePotentialSt
mass	CoMDTypes.h	/^   real_t mass;     \/\/!< mass in internal units$/;"	m	struct:SpeciesDataSt
mass	eam.c	/^   real_t mass;            \/\/!< mass of atoms in intenal units$/;"	m	struct:EamPotentialSt	file:
mass	ljForce.c	/^   real_t mass;            \/\/!< mass of atoms in intenal units$/;"	m	struct:LjPotentialSt	file:
maxIntParallel	parallel.c	/^void maxIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
maxOccupancy	linkCells.c	/^int maxOccupancy(LinkCell* boxes)$/;"	f
maxRank	performanceTimers.c	/^   int maxRank;        \/\/!< rank with max value$/;"	m	struct:TimersSt	file:
maxRankDoubleParallel	parallel.c	/^void maxRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
maxValue	performanceTimers.c	/^   double maxValue;    \/\/!< max over ranks$/;"	m	struct:TimersSt	file:
minRank	performanceTimers.c	/^   int minRank;        \/\/!< rank with min value$/;"	m	struct:TimersSt	file:
minRankDoubleParallel	parallel.c	/^void minRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
minValue	performanceTimers.c	/^   double minValue;    \/\/!< min over ranks$/;"	m	struct:TimersSt	file:
mkAtomCellList	haloExchange.c	/^int* mkAtomCellList(LinkCell* boxes, enum HaloFaceOrder iFace, const int nCells)$/;"	f
mkForceRecvCellList	haloExchange.c	/^int* mkForceRecvCellList(LinkCell* boxes, int face, int nCells)$/;"	f
mkForceSendCellList	haloExchange.c	/^int* mkForceSendCellList(LinkCell* boxes, int face, int nCells)$/;"	f
mkSeed	random.c	/^uint64_t mkSeed(uint32_t id, uint32_t callSite)$/;"	f
moveAtom	linkCells.c	/^void moveAtom(LinkCell* boxes, Atoms* atoms, int iId, int iBox, int jBox)$/;"	f
myOptionAlloc	cmdLineParser.c	/^static MyOption* myOptionAlloc($/;"	f	file:
myOptionFree	cmdLineParser.c	/^static MyOption* myOptionFree(MyOption* o)$/;"	f	file:
myRank	parallel.c	/^int myRank = 0;$/;"	v
myargs	cmdLineParser.c	/^static MyOption* myargs=NULL;$/;"	v	file:
n	eam.c	/^   int n;          \/\/!< the number of values in the table$/;"	m	struct:InterpolationObjectSt	file:
nAtoms	linkCells.h	/^   int* nAtoms;         \/\/!< total number of atoms in each box$/;"	m	struct:LinkCellSt
nAtoms0	CoMDTypes.h	/^   int nAtoms0;  \/\/<! Initial global number of atoms$/;"	m	struct:ValidateSt
nCells	haloExchange.c	/^   int nCells[6];        \/\/!< Number of cells in cellList for each face.$/;"	m	struct:AtomExchangeParmsSt	file:
nCells	haloExchange.c	/^   int nCells[6];     \/\/!< Number of cells to send\/recv for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
nGlobal	initAtoms.h	/^   int nGlobal;   \/\/!< total number of atoms in simulation$/;"	m	struct:AtomsSt
nHaloBoxes	linkCells.h	/^   int nHaloBoxes;      \/\/!< total number of remote halo\/ghost boxes on processor$/;"	m	struct:LinkCellSt
nLocal	initAtoms.h	/^   int nLocal;    \/\/!< total number of atoms on this processor$/;"	m	struct:AtomsSt
nLocalBoxes	linkCells.h	/^   int nLocalBoxes;     \/\/!< total number of local boxes on processor$/;"	m	struct:LinkCellSt
nRanks	parallel.c	/^int nRanks = 1;$/;"	v
nSteps	CoMDTypes.h	/^   int nSteps;            \/\/<! number of time steps to run$/;"	m	struct:SimFlatSt
nSteps	mycommand.h	/^   int nSteps;         \/\/!< number of time steps to run$/;"	m	struct:CommandSt
nTotalBoxes	linkCells.h	/^   int nTotalBoxes;     \/\/!< total number of boxes on processor$/;"	m	struct:LinkCellSt
name	CoMDTypes.h	/^   char  name[3];	   \/\/!< element name$/;"	m	struct:BasePotentialSt
name	CoMDTypes.h	/^   char  name[3];   \/\/!< element name$/;"	m	struct:SpeciesDataSt
name	eam.c	/^   char  name[3];	   \/\/!< element name$/;"	m	struct:EamPotentialSt	file:
name	ljForce.c	/^   char  name[3];	   \/\/!< element name$/;"	m	struct:LjPotentialSt	file:
nbrRank	haloExchange.h	/^   int nbrRank[6];$/;"	m	struct:HaloExchangeSt
next	cmdLineParser.c	/^   void* next;$/;"	m	struct:MyOptionSt	file:
nextOption	cmdLineParser.c	19;"	d	file:
notAlloyReady	eam.c	/^void notAlloyReady(const char* callSite)$/;"	f
numberOfTimers	performanceTimers.h	/^   numberOfTimers};$/;"	e	enum:TimerHandle
nx	mycommand.h	/^   int nx;             \/\/!< number of unit cells in x$/;"	m	struct:CommandSt
ny	mycommand.h	/^   int ny;             \/\/!< number of unit cells in y$/;"	m	struct:CommandSt
nz	mycommand.h	/^   int nz;             \/\/!< number of unit cells in z$/;"	m	struct:CommandSt
p	initAtoms.h	/^   real3*  p;     \/\/!< momenta of atoms$/;"	m	struct:AtomsSt
parms	haloExchange.h	/^   void* parms;$/;"	m	struct:HaloExchangeSt
parseCommandLine	mycommand.c	/^Command parseCommandLine(int argc, char** argv)$/;"	f
pbcFactor	haloExchange.c	/^   real_t* pbcFactor[6]; \/\/!< Whether this face is a periodic boundary.$/;"	m	struct:AtomExchangeParmsSt	file:
perfGlobal	performanceTimers.c	/^static TimerGlobal perfGlobal;$/;"	v	file:
perfTimer	performanceTimers.c	/^static Timers perfTimer[numberOfTimers];$/;"	v	file:
phi	eam.c	/^   InterpolationObject* phi;  \/\/!< Pair energy$/;"	m	struct:EamPotentialSt	file:
positionTimer	performanceTimers.h	/^   positionTimer, $/;"	e	enum:TimerHandle
pot	CoMDTypes.h	/^   BasePotential *pot;	  \/\/!< the potential$/;"	m	struct:SimFlatSt
potDir	mycommand.h	/^   char potDir[1024];  \/\/!< the directory where EAM potentials reside$/;"	m	struct:CommandSt
potName	mycommand.h	/^   char potName[1024]; \/\/!< the name of the potential$/;"	m	struct:CommandSt
potType	mycommand.h	/^   char potType[1024]; \/\/!< the type of the potential (funcfl or setfl)$/;"	m	struct:CommandSt
print	CoMDTypes.h	/^   void (*print)(FILE* file, struct BasePotentialSt* pot);$/;"	m	struct:BasePotentialSt
print	eam.c	/^   void (*print)(FILE* file, BasePotential* pot);$/;"	m	struct:EamPotentialSt	file:
print	ljForce.c	/^   void (*print)(FILE* file, BasePotential* pot);$/;"	m	struct:LjPotentialSt	file:
printArgs	cmdLineParser.c	/^void printArgs()$/;"	f
printCmdYaml	mycommand.c	/^void printCmdYaml(FILE* file, Command* cmd)$/;"	f
printPerformanceResults	performanceTimers.c	/^void printPerformanceResults(int nGlobalAtoms, int printRate)$/;"	f
printPerformanceResultsYaml	performanceTimers.c	/^void printPerformanceResultsYaml(FILE* file)$/;"	f
printRank	parallel.c	/^int printRank()$/;"	f
printRate	CoMDTypes.h	/^   int printRate;         \/\/<! number of steps between output$/;"	m	struct:SimFlatSt
printRate	mycommand.h	/^   int printRate;      \/\/!< number of steps between output$/;"	m	struct:CommandSt
printSeparator	yamlOutput.c	/^void printSeparator(FILE* file)$/;"	f
printSimulationDataYaml	CoMD.c	/^void printSimulationDataYaml(FILE* file, SimFlat* s)$/;"	f
printTableData	eam.c	/^void printTableData(InterpolationObject* table, const char* fileName)$/;"	f
printThings	CoMD.c	/^void printThings(SimFlat* s, int iStep, double elapsedTime)$/;"	f
procCoord	decomposition.h	/^   int procCoord[3];       \/\/!< i,j,k for this processor$/;"	m	struct:DomainSt
procGrid	decomposition.h	/^   int procGrid[3];        \/\/!< number of processors in each dimension$/;"	m	struct:DomainSt
processArgs	cmdLineParser.c	/^void processArgs(int argc, char** argv)$/;"	f
processorNum	decomposition.c	/^int processorNum(Domain* domain, int dix, int diy, int diz)$/;"	f
profileStart	performanceTimers.c	/^void profileStart(const enum TimerHandle handle)$/;"	f
profileStop	performanceTimers.c	/^void profileStop(const enum TimerHandle handle)$/;"	f
ptr	cmdLineParser.c	/^   void* ptr;$/;"	m	struct:MyOptionSt	file:
putAtomInBox	linkCells.c	/^void putAtomInBox(LinkCell* boxes, Atoms* atoms,$/;"	f
px	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
py	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
pz	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
r	initAtoms.h	/^   real3*  r;     \/\/!< positions$/;"	m	struct:AtomsSt
randomDisplacements	initAtoms.c	/^void randomDisplacements(SimFlat* s, real_t delta)$/;"	f
rank	parallel.h	/^   int rank;$/;"	m	struct:RankReduceDataSt
real3	mytype.h	/^typedef real_t real3[3]; \/\/!< a convenience vector with three real_t $/;"	t
real_t	mytype.h	/^typedef double real_t; \/\/!< define native type for CoMD as double precision$/;"	t
real_t	mytype.h	/^typedef float real_t;  \/\/!< define native type for CoMD as single precision$/;"	t
recvCells	haloExchange.c	/^   int* recvCells[6]; \/\/!< List of link cells to recv for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
redistributeAtoms	timestep.c	/^void redistributeAtoms(SimFlat* sim)$/;"	f
redistributeTimer	performanceTimers.h	/^   redistributeTimer, $/;"	e	enum:TimerHandle
rho	eam.c	/^   InterpolationObject* rho;  \/\/!< Electron Density$/;"	m	struct:EamPotentialSt	file:
rhobar	eam.c	/^   real_t* rhobar;        \/\/!< per atom storage for rhobar$/;"	m	struct:EamPotentialSt	file:
rx	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
ry	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
rz	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
sanityChecks	CoMD.c	/^void sanityChecks(Command cmd, double cutoff, double latticeConst, char latticeType[8])$/;"	f
screenOut	mytype.h	27;"	d
sendCells	haloExchange.c	/^   int* sendCells[6]; \/\/!< List of link cells to send for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
sendReceiveParallel	parallel.c	/^int sendReceiveParallel(void* sendBuf, int sendLen, int dest,$/;"	f
serprvAtoms	initAtoms.c	/^void serprvAtoms(Atoms* atoms, int maxTotalAtoms)$/;"	f
serprvDomain	decomposition.c	/^void serprvDomain(Domain* domain)$/;"	f
serprvHaloExchange	haloExchange.c	/^void serprvHaloExchange(HaloExchange* hh)$/;"	f
serprvLinkCell	linkCells.c	/^void serprvLinkCell(LinkCell* ll)$/;"	f
serprvLjPot	ljForce.c	/^void serprvLjPot(LjPotential* pot)$/;"	f
serprvSpeciesData	CoMD.c	/^void serprvSpeciesData(SpeciesData* species)$/;"	f
setTemperature	initAtoms.c	/^void setTemperature(SimFlat* s, real_t temperature)$/;"	f
setVcm	initAtoms.c	/^void setVcm(SimFlat* s, real_t newVcm[3])$/;"	f
shortArg	cmdLineParser.c	/^   unsigned char shortArg[2];$/;"	m	struct:MyOptionSt	file:
sigma	ljForce.c	/^   real_t sigma;$/;"	m	struct:LjPotentialSt	file:
sortAtomsById	haloExchange.c	/^int sortAtomsById(const void* a, const void* b)$/;"	f
sortAtomsInCell	haloExchange.c	/^void sortAtomsInCell(Atoms* atoms, LinkCell* boxes, int iBox)$/;"	f
species	CoMDTypes.h	/^   SpeciesData* species;  \/\/<! species data (per species, not per atom)$/;"	m	struct:SimFlatSt
start	performanceTimers.c	/^   uint64_t start;     \/\/!< call start time$/;"	m	struct:TimersSt	file:
startTimer	performanceTimers.h	39;"	d
startTimer	performanceTimers.h	50;"	d
stdev	performanceTimers.c	/^   double stdev;       \/\/!< stdev across ranks$/;"	m	struct:TimersSt	file:
stopTimer	performanceTimers.h	44;"	d
stopTimer	performanceTimers.h	51;"	d
sumAtoms	CoMD.c	/^void sumAtoms(SimFlat* s)$/;"	f
sz	cmdLineParser.c	/^   int sz;$/;"	m	struct:MyOptionSt	file:
temperature	mycommand.h	/^   double temperature; \/\/!< simulation initial temperature (in Kelvin)$/;"	m	struct:CommandSt
timerName	performanceTimers.c	/^char* timerName[numberOfTimers] = {$/;"	v
timerStats	performanceTimers.c	/^void timerStats(void)$/;"	f
timestampBarrier	parallel.c	/^void timestampBarrier(const char* msg)$/;"	f
timestep	timestep.c	/^double timestep(SimFlat* s, int nSteps, real_t dt)$/;"	f
timestepTimer	performanceTimers.h	/^   timestepTimer, $/;"	e	enum:TimerHandle
total	performanceTimers.c	/^   uint64_t total;     \/\/!< current total time$/;"	m	struct:TimersSt	file:
totalTimer	performanceTimers.h	/^   totalTimer, $/;"	e	enum:TimerHandle
type	cmdLineParser.c	/^   char type;$/;"	m	struct:MyOptionSt	file:
type	haloExchange.c	/^   int type;$/;"	m	struct:AtomMsgSt	file:
typeNotSupported	eam.c	/^void typeNotSupported(const char* callSite, const char* type)$/;"	f
unloadAtomsBuffer	haloExchange.c	/^void unloadAtomsBuffer(void* vparms, void* data, int face, int bufSize, char* charBuf)$/;"	f
unloadBuffer	haloExchange.h	/^   void (*unloadBuffer)(void* parms, void* data, int face, int bufSize, char* buf);$/;"	m	struct:HaloExchangeSt
unloadForceBuffer	haloExchange.c	/^void unloadForceBuffer(void* vparms, void* vdata, int face, int bufSize, char* charBuf)$/;"	f
updateLinkCells	linkCells.c	/^void updateLinkCells(LinkCell* boxes, Atoms* atoms)$/;"	f
val	parallel.h	/^   double val;$/;"	m	struct:RankReduceDataSt
validateResult	CoMD.c	/^void validateResult(const Validate* val, SimFlat* sim)$/;"	f
values	eam.c	/^   real_t* values; \/\/!< the abscissa values$/;"	m	struct:InterpolationObjectSt	file:
velocityTimer	performanceTimers.h	/^   velocityTimer,  $/;"	e	enum:TimerHandle
x0	eam.c	/^   real_t x0;      \/\/!< the starting ordinate range$/;"	m	struct:InterpolationObjectSt	file:
xproc	mycommand.h	/^   int xproc;          \/\/!< number of processors in x direction$/;"	m	struct:CommandSt
yamlAppInfo	yamlOutput.c	/^void yamlAppInfo(FILE* file)$/;"	f
yamlBegin	yamlOutput.c	/^void yamlBegin(void)$/;"	f
yamlEnd	yamlOutput.c	/^void yamlEnd(void)$/;"	f
yamlFile	yamlOutput.c	/^FILE* yamlFile = NULL;$/;"	v
yproc	mycommand.h	/^   int yproc;          \/\/!< number of processors in y direction$/;"	m	struct:CommandSt
zeroReal3	mytype.h	/^static void zeroReal3(real3 a)$/;"	f
zproc	mycommand.h	/^   int zproc;          \/\/!< number of processors in z direction$/;"	m	struct:CommandSt
